<70.모든 콘텐츠가 컴포넌트에 보관될 필요가 없는 이유>
    +>index.html
        1) index.jsx에서 이 div를 지정할 때 root id를 포함하여 앱 컴포넌트를 렌더링하는 것이 div의 내용
        2) index.html은 결국 웹사이트를 진입할때 볼 내용
        3) 그러므로 리액트에서 작업할 때 필요하다면 여기에 마크업을 더할 수 있음
        4) 다른 데이터의 영향을 받지 않고 영향을 주지 않는 마크업(태그)는 index.html에 존재해도 됨
        => 컴포넌트에 모든 요소를 다 넣지 않아도 됨.
    +>public 폴더
        1) 해당 폴더에 어떤 파일이 있던 방문객에게도 공개
        2) 따로 경로를 지정하지 않아도 됨
        ex) index.html 에서 img 태그에 src(경로)를 작성한다면 public/game-logo.png 작성(X)
            웹 어플리케이션의 루트를 가져오기 떄문에 잘못 작성된 경로이고 방문자가 접근할 수 없음

    ▶header 태그를 리액트 컴포너트 바깥으로 옮김


<71.세부과정: 이미지 저장소는 public/ VS assets/
    세부 과정: 이미지 저장소는 public/ VS assets/
    +>  public/ 폴더
        이미지를 public/ 폴더에 저장하고 index.html 또는 index.css 파일 내에서 직접 참조할 수 있으며,
        이렇게 하는 이유는 public/에 저장된 이미지 (또는 일반적으로: 파일)이 프로젝트 개발 서버 및 빌드 프로세스에 의해 공개적으로 제공되기 때문임
        index.html과 마찬가지로, 이 파일들은 브라우저 내에서 직접 방문할 수 있으며, 따라서 다른 파일에 의해 요청될 수도 있슴
        
        ex)localhost:5173/some-image.jpg를 불러오면 해당 이미지를 볼 수 있습니다 (물론 public/ 폴더에 이미지가 있을 경우).

    +>  src/assets/ 폴더
        이미지를 src/assets/ 폴더 (또는 실제로는 src폴더의 어디든)에 저장할 수도 있습니다.

    ?> public/와 비교해 어떤 차이?
        src 또는 src/assets/와 같은 하위 폴더에 저장된 모든 파일(어떤 형식이든)은 공개적으로 제공되지 않습니다. 웹사이트 방문자가 접근할 수 없습니다. 
        localhost:5173/src/assets/some-image.jpg 를 불러오려고 하면 오류가 발생합니다.
        대신,src/ (및 하위 폴더)에 저장된 파일은 코드 파일에서 사용할 수 있습니다. 코드 파일에 가져온 이미지는 빌드 프로세스에 의해 인식되어 최적화되며,
        웹사이트에 제공하기 직전에 public/ 폴더에 "삽입"됩니다. 
        가져온 이미지는 참조한 위치에서 자동으로 링크가 생성되어 사용됩니다.

    ▶  어떤 폴더를 사용해야 할까?
        빌드 프로세스에 의해 처리되지 않는 이미지는public/폴더를 사용해야 하고 대체적으로 사용 가능 가능합니다. 
        예를 들면 index.html 파일이나 파비콘과 같은 이미지가 좋은 후보입니다.
        반면, 컴포넌트 내에서 사용되는 이미지는 일반적으로src/폴더(예: src/assets/)에 저장되어야 합니다.

<72.개념 복습: 컴포넌트 분리 & 재사용 가능한 컴포넌트 구축>
    +> 동일한 마크업을 2개이상 반복되는 현상 => 컴포넌트를 새로 하나 만드는 것이 좋음
        why> 차후 구조 변경 또는 유지보수를 위하여

<75.컴포넌트 인스턴스의 분리된 동작법>
    +>  즉 이 두 컴포넌트는 동일한 로직을 공유하고 있지만 컴포넌트를 사용하는 순간 완전히 분리된 인스턴스가 각각 생성되어
        동일한 로직을 사용할지라도 사용하는 위치가 따로 분리 리액트를 이해하는 데에 아주 중요한 부분!!!
        이렇게 분리되는 속성을 이용해 아주 복잡한 컴포넌트를 만들어서 재사용 시 서로에게 영향을 주지 않게 할 수 있음

※이벤트 처리하기※
    1)        
        function Form() {
            function handleSubmit(e) {
                e.preventDefault();
                console.log('You clicked submit.');
            }

            return (
                <form onSubmit={handleSubmit}>
                <button type="submit">Submit</button>
                </form>
            );
        }
        *>반드시 preventDefault를 명시적으로 호출

    2)이벤트 핸들러에 인자 전달하기
        <button onClick={(e) => this.deleteRow(id, e)}>Delete Row</button>
        <button onClick={this.deleteRow.bind(this, id)}>Delete Row</button>
        *>  위 두 줄은 동등하며 각각 화살표 함수와 Function.prototype.bind를 사용 
            두 경우 모두 React 이벤트를 나타내는 e 인자가 ID 뒤에 두 번째 인자로 전달됩니다. 
            화살표 함수를 사용하면 명시적으로 인자를 전달해야 하지만 bind를 사용할 경우 추가 인자가 자동으로 전달

<77. 추천 실습: 옛 State(상태)를 기반으로 올바르게 상태 업데이트하기>
    +>  ★ 상태 변경시 이전의 상태값에 기반하여 변경한다면?★
            상태 변경 시 이전의 상태값에기반하여 변경한다면 함수 형태를 써야함
         setIsEditing((editing) => !editing);



<78.사용자 입력&양방향 바인딩>
    +> 양방향 바인딩
        참고로 입력값의 변화에 반응하고 변경된 값을 다시 입력값에 전달하는 방식을 양방향 바인딩
        이 입력값에서 값을 빼내어 다른 값을 다시 여기에 전달하기 때문







